 {
        function* flattenContent(content) {
            if(Array.isArray(content)) {
                for(const item of content) {
                    if(Array.isArray(item)) {
                        for(const flat of flattenContent(item)) {
                            yield flat;
                        }
                    } else if(item!==undefined) {
                        if(item?.content) {
                            item.content = [...flattenContent(item.content)].reduce((array,item,i) => {
                                if(typeof(item)==="string" && typeof(array[i-1])==="string") {
                                    array[i-1] += item;
                                } else {
                                    array.push(item);
                                }
                                return array;
                            },[]);
                        }
                        yield item;
                    }
                }
            }
            return content;
        }

        class Tag {
            constructor({tag,options,content,location}) {
                const {attributes, classes, id } = options||{};
                Object.assign(this,{tag,id,classes,attributes,content});
                Object.defineProperty(this,"location",{value:location});
            }
            toString() {
                let string = ":" + this.tag;
                if(this.tag.startsWith("@")) {
                    string = this.tag;
                }
                if(this.tag==="hashtag") {
                    return this.content.reduce((tags,item) => {
                       item.split(" ").forEach((tag) => tags.push("#" + tag.trim()));
                       return tags;
                   },[]).join(", ").trim()
                }
                const attributes = Object.entries(this.attributes||{}),
                    classes = this.classes || [];
                if(this.id || classes.length>0 || attributes.length>0) {
                    string += "(";
                    if(this.id) string += "#" + this.id + " ";
                    if(classes.length>0) {
                        classes.forEach((className) => string += className + " ");
                    }
                    if(attributes.length>0) {
                        attributes.forEach(([key,value]) => {
                            string += (value==="" ? key : `${key}="${value}"`) + " ";
                        });
                    }
                    string = string.trim() + ")";
                }
                const bracket = this.content.length>0;
                string += (bracket ? "[" : "") + this.content.map((item) => typeof(item)==="string" ? item : item.toString()).join(" ") + (bracket ? "]" : "");
                return string;
            }
        }
    }
    start
        = _ content:content* _ {
                return [...flattenContent(content)];
            }

    content
        = escape / script / code /  value / hr / br / (&colon expression _?) / backtickquoted / [ a-z0-9_\-~!@#$%^&*()_+=\[\{\]\}|\\;:"'<,>.?/\n\r\t]i

    colon
        = ":"

    expression
        = &colon tag:tag options:options?  bracketed:bracketed  {
             const content = bracketed || [];
             return new Tag({tag,options,content,location:location()});
        }

    hr
     = ":hr" options:options? bracketed:bracketed? {
        return new Tag({tag:"hr",options,location:location()})
     }

    br
      = ":br" options:options? bracketed:bracketed? {
         return new Tag({tag:"br",options,location:location()})
      }

    value
        = ":value" options:options?  bracketed:bracketed?  {
             const content = bracketed || [];
             return new Tag({tag:"value",options,content,location:location()});
        }

    escape
            = ":escape" options:options? bracketed:bracketed {
                 const content = [bracketed.map((item) => typeof(item)==="string" ? item : item.toString()).join("")] ;
                 return new Tag({tag:"escape",options,content,location:location()});
            }

    script
        = ":script" options:options? bracketed:bracketed {
             const content = [bracketed.map((item) => typeof(item)==="string" ? item : item.toString()).join("")] ;
             return new Tag({tag:"script",options,content,location:location()});
        }

    code
        = ":code" options:options? bracketed:bracketed {
             const content = [bracketed.map((item) => typeof(item)==="string" ? item : item.toString()).join("")] ;
             return new Tag({tag:"code",options,content,location:location()});
        }

    symbol
        = ampersand special:[\#a-z0-9]i* ";" {;
            return new Tag({tag:"&",content:[special.join("")],location:location()})
        }

    ampersand
        = "&"

    hashtag
        = hash tag:[a-z0-9\-]i* options:options? content:bracketed {
            return new Tag({tag:"hashtag",options,content:tag.length>0 ? [tag.join("")] : content,location:location()})
        }

    hash
        = "#"

    mention
        = at site:[a-z0-9]i* options:options? content:bracketed {
            return new Tag({tag:"@"+site.join(""),options,content,location:location()});
        }

    at "at"
        = "@"

    bracketed "bracketed"
        = BRACKETOPEN value:(symbol/hashtag/mention/escape/script/code/value/hr/br/expression/not_bracketed/bracketed)* BRACKETCLOSE {
            if(Array.isArray(value) && value.every((item) => typeof(item)==="string")) {
                return [value.join("")];
            }
            const result = [];
            for(let i=0;i<value.length;i++) {
                const item = value[i];
                if(Array.isArray(item)) {
                    const text = "[" + item.join(" ") + "]";
                    if(typeof(result[result.length-1])!=="string") {
                        result.push(text);
                    } else {
                         result[result.length-1] += text;
                    }
                } else if(item && typeof(item)==="object") {
                    result.push(item);
                } else {
                    if(typeof(result[result.length-1])!=="string") {
                        result.push(item);
                    } else {
                        result[result.length-1] += item;
                    }
                }
            }
            return result;
        }

    not_bracketed
        = not:(!BRACKETCLOSE !BRACKETOPEN.) {
                return not.join("");
        }

    BRACKETOPEN = '['

    BRACKETCLOSE = ']'

    backtickquoted "backtickquoted"
            = BACKTICKOPEN text:(not_backtickquoted/backtickquoted)*  BACKTICKCLOSE { return text.join("") }

        not_backtickquoted
            = not:(!BACKTICKOPEN !BACKTICKOPEN.) { return not.join("");}

        BACKTICKOPEN = '`'

        BACKTICKCLOSE = '`'

    tag
        = colon token:token { return token }

    options "options"
        = "(" _ id:id? _ attributes:attributelist? _ classes:class* _ ")" {
            var o = {};
            o.id=id;
            o.classList = classes;
            o.attributes = (attributes||[]).reduce((attributes,[name,value]) => { attributes[name] = value; return attributes; },{}); return o;
        }

    id
        = "#" token:token { return token }

    class
        = "." cls:token { return cls }

    keyvaluelist "key value list"
        = first:keyvalue rest:( _ "," keyvalue)* { return [first,...rest.map((value) => value.pop())] }

    keyvalue "key value pair"
        = key:token _ ":" _ ["] value:[ a-z0-9_\-~`!@#$%^&*()_+=\[\]|\;'<>.?/]i* ["] { return [key,value.join("")]; }

    attributelist
        = attribute:(binaryattribute / attribute) _ attributelist:attributelist* { return [attribute].concat(...attributelist) }

    attribute
        =  name:token _ "=" _ value:quoted { return [name,value] }

    binaryattribute
        = hidden / checked / colored / disabled / editable / fitcontent/ open / readonly / reversed / run / selected / static / toggle / url / visible

    hidden
        = "hidden" { return ["hidden",""] }

    checked
        = "checked" { return ["checked",""] }

    colored
            = "colored" { return ["colored",""] }

    editable
        = "editable" { return ["editable",""] }

    disabled
        = "disabled" { return ["disabled",""] }

    fitcontent
        = "fitcontent" { return ["fitcontent",""] }

    readonly
        = "readonly" { return ["readonly",""] }

    reversed
        = "reversed" { return ["reversed",""] }

    run
        = "run" { return ["run",""] }

    open
        = "open" { return ["open",""] }

    selected
        = "selected" { return ["selected",""] }

    static
        = "static" { return ["static",""] }

    toggle
        = "toggle" { return ["toggle",""] }

    url
        = prefix:urlprefix path:[a-z0-9_\-~`!@#$%^&*_+=\{\}\[\]|\\:;'<,>.?/]i* {
            try { new URL(path.join(),document.baseURI); return ["url",prefix+path.join("")]; }
            catch(e) { error(e+"") }
        }

    visible
        = "visible" { return ["visible",""] }

    urlprefix
        = "https://" / "./"

    token
        = start:[a-z~!$%&*:@#]i rest:[a-z$%&*:@#0-9_\-]i* { return start + rest.join("") }

    quoted
       = [\"] value:string [\"] { return value }

    string
        = value:[ a-z0-9_\-~`!@#$%^&*()_+=\{\}\[\]|\\:;'<,>.?/]i* { return value.join("") }

    _ "whitespace"
        = whitespace:[ \t\n\r]* { return whitespace.join("") }